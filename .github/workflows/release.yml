name: Release (with lint and test)

on:
  push:
    tags:
      - "*"

jobs:
  lint:
    name: lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.2'

      - name: Install dependencies
        run: |
          go mod tidy

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest
          args: --timeout 3m
  test:
    name: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.2'

      - name: run tests
        run: |
          go mod tidy
          make tests
  
  build-create-release:
    runs-on: ubuntu-latest
    needs: [lint, test]
    permissions: write-all
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check and set release version
        env:
          REF: ${{ github.ref }}
        run: |
          ./scripts/version.sh $REF

      - name: Build binary
        env:
          RELEASE_BUCKET_NAME: ${{ secrets.RELEASE_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          TELEMETRY_TOKEN: ${{ secrets.TELEMETRY_TOKEN }}
        run: |
          go mod tidy
          
          VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "Building binary for version $VERSION"
          make release
          sudo chown -R $USER:$USER .
          ./scripts/bundleReleases.sh $VERSION
          
          # Create the content using a heredoc assigned to a variable
          RELEASE_BODY=$(cat << 'EOF'
          ## Downloads
          EOF
          )
          
          # Create a temporary file to build up the release body
          echo "$RELEASE_BODY" > release_body_temp.txt
          
          for asset_name in $(ls ./release | grep '.tar');
          do
          asset="./release/${asset_name}"
          echo "Uploading ${asset_name}..."
          aws s3 cp "$asset" "s3://${RELEASE_BUCKET_NAME}/$VERSION/"
          
          # append to the release body file with proper newlines
          echo "- [${asset_name}](https://s3.amazonaws.com/${RELEASE_BUCKET_NAME}/$VERSION/${asset_name})" >> release_body_temp.txt
          done
          
          # Read the complete release body from the file
          RELEASE_BODY=$(cat release_body_temp.txt)
          
          # Set it as an environment variable for later steps
          echo 'RELEASE_BODY<<EOF' >> $GITHUB_ENV
          echo "$RELEASE_BODY" >> $GITHUB_ENV
          echo 'EOF' >> $GITHUB_ENV

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false
          body: ${{ env.RELEASE_BODY }}

      - name: Upload Release Asset
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BUCKET_NAME: ${{ vars.RELEASE_BUCKET_NAME }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -x
          ls -al ./release
      
          echo "Upload URL: ${{ steps.create_release.outputs.upload_url }}"
          export upload_url=$(echo "${{ steps.create_release.outputs.upload_url }}" | sed -e "s/{?name,label}//")
      
          for asset_name in $(ls ./release | grep '.tar');
          do
            asset="./release/${asset_name}"
            echo "Uploading ${asset_name}..."
            curl --fail \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Content-Type: $(file -b --mime-type "$asset")" \
              --data-binary @"$asset" \
              "${upload_url}?name=$asset_name"
          done

  smoke-test-binaries:
    needs: build-create-release 
    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest]
        arch: [x64, arm64]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repo @ tag
        uses: actions/checkout@v4

      - name: Read version
        id: ver
        run: |
          version=$(<VERSION)
          echo "::set-output name=VERSION::$version"

      - name: Install devkit
        run: |
          set -euxo pipefail
          ver="${{ steps.ver.outputs.VERSION }}"
          case "${{ matrix.os }}-${{ matrix.arch }}" in
            "macos-latest-x64")   url="https://s3.amazonaws.com/eigenlayer-devkit-releases/${ver}/devkit-darwin-amd64-${ver}.tar.gz" ;;
            "macos-latest-arm64") url="https://s3.amazonaws.com/eigenlayer-devkit-releases/${ver}/devkit-darwin-arm64-${ver}.tar.gz" ;;
            "ubuntu-latest-x64")  url="https://s3.amazonaws.com/eigenlayer-devkit-releases/${ver}/devkit-linux-amd64-${ver}.tar.gz" ;;
            "ubuntu-latest-arm64")url="https://s3.amazonaws.com/eigenlayer-devkit-releases/${ver}/devkit-linux-arm64-${ver}.tar.gz" ;;
            *) echo "Unsupported combination"; exit 1 ;;
          esac
          mkdir -p "$HOME/bin"
          echo "::set-output name=url::$url"
          curl -fsSL "$url" | tar xv -C "$HOME/bin"

      - name: Verify installation
        run: |
          export PATH="$HOME/bin:$PATH"
          # expected version from file
          ver="${{ steps.ver.outputs.VERSION }}"
          # extract the Version line (e.g. "v0.0.7") without dropping the prefix
          installed=$(devkit version \
            | awk '/^Version:/ { print $2 }')
          if [[ "$installed" != "$ver" ]]; then
            echo "✖ version mismatch: expected $ver, got $installed"
            exit 1
          fi
          echo "✔ version $installed matches expected $ver"
